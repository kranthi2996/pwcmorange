"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const messages_1 = require("@cucumber/messages");
const multimaps_1 = require("@teppeis/multimaps");
const lodash_sortby_1 = __importDefault(require("lodash.sortby"));
const helpers_1 = require("./helpers");
class Query {
    constructor() {
        this.testCaseStartedById = new Map();
        this.lineageById = new Map();
        this.stepById = new Map();
        this.pickleById = new Map();
        this.pickleStepById = new Map();
        this.hookById = new Map();
        this.stepDefinitionById = new Map();
        this.testCaseById = new Map();
        this.testStepById = new Map();
        this.testCaseFinishedByTestCaseStartedId = new Map();
        this.testRunHookStartedById = new Map();
        this.testRunHookFinishedByTestRunHookStartedId = new Map();
        this.testStepStartedByTestCaseStartedId = new multimaps_1.ArrayMultimap();
        this.testStepFinishedByTestCaseStartedId = new multimaps_1.ArrayMultimap();
        this.attachmentsByTestCaseStartedId = new multimaps_1.ArrayMultimap();
        this.attachmentsByTestRunHookStartedId = new multimaps_1.ArrayMultimap();
        this.suggestionsByPickleStepId = new multimaps_1.ArrayMultimap();
        this.undefinedParameterTypes = [];
    }
    update(envelope) {
        if (envelope.meta) {
            this.meta = envelope.meta;
        }
        if (envelope.gherkinDocument) {
            this.updateGherkinDocument(envelope.gherkinDocument);
        }
        if (envelope.pickle) {
            this.updatePickle(envelope.pickle);
        }
        if (envelope.hook) {
            this.hookById.set(envelope.hook.id, envelope.hook);
        }
        if (envelope.stepDefinition) {
            this.stepDefinitionById.set(envelope.stepDefinition.id, envelope.stepDefinition);
        }
        if (envelope.testRunStarted) {
            this.testRunStarted = envelope.testRunStarted;
        }
        if (envelope.testRunHookStarted) {
            this.updateTestRunHookStarted(envelope.testRunHookStarted);
        }
        if (envelope.testRunHookFinished) {
            this.updateTestRunHookFinished(envelope.testRunHookFinished);
        }
        if (envelope.testCase) {
            this.updateTestCase(envelope.testCase);
        }
        if (envelope.testCaseStarted) {
            this.updateTestCaseStarted(envelope.testCaseStarted);
        }
        if (envelope.testStepStarted) {
            this.updateTestStepStarted(envelope.testStepStarted);
        }
        if (envelope.attachment) {
            this.updateAttachment(envelope.attachment);
        }
        if (envelope.testStepFinished) {
            this.updateTestStepFinished(envelope.testStepFinished);
        }
        if (envelope.testCaseFinished) {
            this.updateTestCaseFinished(envelope.testCaseFinished);
        }
        if (envelope.testRunFinished) {
            this.testRunFinished = envelope.testRunFinished;
        }
        if (envelope.suggestion) {
            this.updateSuggestion(envelope.suggestion);
        }
        if (envelope.undefinedParameterType) {
            this.updateUndefinedParameterType(envelope.undefinedParameterType);
        }
    }
    updateGherkinDocument(gherkinDocument) {
        if (gherkinDocument.feature) {
            this.updateFeature(gherkinDocument.feature, {
                gherkinDocument,
            });
        }
    }
    updateFeature(feature, lineage) {
        feature.children.forEach((featureChild) => {
            if (featureChild.background) {
                lineage.background = featureChild.background;
                this.updateSteps(featureChild.background.steps);
            }
            if (featureChild.scenario) {
                this.updateScenario(featureChild.scenario, Object.assign(Object.assign({}, lineage), { feature }));
            }
            if (featureChild.rule) {
                this.updateRule(featureChild.rule, Object.assign(Object.assign({}, lineage), { feature }));
            }
        });
    }
    updateRule(rule, lineage) {
        rule.children.forEach((ruleChild) => {
            if (ruleChild.background) {
                lineage.ruleBackground = ruleChild.background;
                this.updateSteps(ruleChild.background.steps);
            }
            if (ruleChild.scenario) {
                this.updateScenario(ruleChild.scenario, Object.assign(Object.assign({}, lineage), { rule }));
            }
        });
    }
    updateScenario(scenario, lineage) {
        this.lineageById.set(scenario.id, Object.assign(Object.assign({}, lineage), { scenario }));
        scenario.examples.forEach((examples, examplesIndex) => {
            this.lineageById.set(examples.id, Object.assign(Object.assign({}, lineage), { scenario,
                examples,
                examplesIndex }));
            examples.tableBody.forEach((example, exampleIndex) => {
                this.lineageById.set(example.id, Object.assign(Object.assign({}, lineage), { scenario,
                    examples,
                    examplesIndex,
                    example,
                    exampleIndex }));
            });
        });
        this.updateSteps(scenario.steps);
    }
    updateSteps(steps) {
        steps.forEach((step) => this.stepById.set(step.id, step));
    }
    updatePickle(pickle) {
        this.pickleById.set(pickle.id, pickle);
        pickle.steps.forEach((pickleStep) => this.pickleStepById.set(pickleStep.id, pickleStep));
    }
    updateTestRunHookStarted(testRunHookStarted) {
        this.testRunHookStartedById.set(testRunHookStarted.id, testRunHookStarted);
    }
    updateTestRunHookFinished(testRunHookFinished) {
        this.testRunHookFinishedByTestRunHookStartedId.set(testRunHookFinished.testRunHookStartedId, testRunHookFinished);
    }
    updateTestCase(testCase) {
        this.testCaseById.set(testCase.id, testCase);
        testCase.testSteps.forEach((testStep) => {
            this.testStepById.set(testStep.id, testStep);
        });
    }
    updateTestCaseStarted(testCaseStarted) {
        this.testCaseStartedById.set(testCaseStarted.id, testCaseStarted);
    }
    updateTestStepStarted(testStepStarted) {
        this.testStepStartedByTestCaseStartedId.put(testStepStarted.testCaseStartedId, testStepStarted);
    }
    updateAttachment(attachment) {
        if (attachment.testCaseStartedId) {
            this.attachmentsByTestCaseStartedId.put(attachment.testCaseStartedId, attachment);
        }
        if (attachment.testRunHookStartedId) {
            this.attachmentsByTestRunHookStartedId.put(attachment.testRunHookStartedId, attachment);
        }
    }
    updateTestStepFinished(testStepFinished) {
        this.testStepFinishedByTestCaseStartedId.put(testStepFinished.testCaseStartedId, testStepFinished);
    }
    updateTestCaseFinished(testCaseFinished) {
        this.testCaseFinishedByTestCaseStartedId.set(testCaseFinished.testCaseStartedId, testCaseFinished);
    }
    updateSuggestion(suggestion) {
        this.suggestionsByPickleStepId.put(suggestion.pickleStepId, suggestion);
    }
    updateUndefinedParameterType(undefinedParameterType) {
        this.undefinedParameterTypes.push(undefinedParameterType);
    }
    countMostSevereTestStepResultStatus() {
        const result = {
            [messages_1.TestStepResultStatus.AMBIGUOUS]: 0,
            [messages_1.TestStepResultStatus.FAILED]: 0,
            [messages_1.TestStepResultStatus.PASSED]: 0,
            [messages_1.TestStepResultStatus.PENDING]: 0,
            [messages_1.TestStepResultStatus.SKIPPED]: 0,
            [messages_1.TestStepResultStatus.UNDEFINED]: 0,
            [messages_1.TestStepResultStatus.UNKNOWN]: 0,
        };
        for (const testCaseStarted of this.findAllTestCaseStarted()) {
            const mostSevereResult = (0, lodash_sortby_1.default)(this.findTestStepFinishedAndTestStepBy(testCaseStarted).map(([testStepFinished]) => testStepFinished.testStepResult), [(testStepResult) => (0, helpers_1.statusOrdinal)(testStepResult.status)]).at(-1);
            if (mostSevereResult) {
                result[mostSevereResult.status]++;
            }
        }
        return result;
    }
    countTestCasesStarted() {
        return this.findAllTestCaseStarted().length;
    }
    findAllPickles() {
        return [...this.pickleById.values()];
    }
    findAllPickleSteps() {
        return [...this.pickleStepById.values()];
    }
    findAllStepDefinitions() {
        return [...this.stepDefinitionById.values()];
    }
    findAllTestCaseStarted() {
        return (0, lodash_sortby_1.default)([...this.testCaseStartedById.values()].filter((testCaseStarted) => {
            const testCaseFinished = this.testCaseFinishedByTestCaseStartedId.get(testCaseStarted.id);
            // only include if not yet finished OR won't be retried
            return !(testCaseFinished === null || testCaseFinished === void 0 ? void 0 : testCaseFinished.willBeRetried);
        }), [
            (testCaseStarted) => messages_1.TimeConversion.timestampToMillisecondsSinceEpoch(testCaseStarted.timestamp),
            'id',
        ]);
    }
    findAllTestCaseFinished() {
        return (0, lodash_sortby_1.default)([...this.testCaseFinishedByTestCaseStartedId.values()].filter((testCaseFinished) => {
            // only include if not yet finished OR won't be retried
            return !(testCaseFinished === null || testCaseFinished === void 0 ? void 0 : testCaseFinished.willBeRetried);
        }), [
            (testCaseFinished) => messages_1.TimeConversion.timestampToMillisecondsSinceEpoch(testCaseFinished.timestamp),
            'id',
        ]);
    }
    findAllTestCaseStartedOrderBy(findOrderBy, order) {
        const withOrderBy = this.findAllTestCaseStarted().map((testCaseStarted) => ({
            testCaseStarted,
            orderBy: findOrderBy(this, testCaseStarted),
        }));
        const sorted = withOrderBy.sort((a, b) => {
            if (a.orderBy === undefined && b.orderBy === undefined)
                return 0;
            if (a.orderBy === undefined)
                return 1;
            if (b.orderBy === undefined)
                return -1;
            return order(a.orderBy, b.orderBy);
        });
        return sorted.map((item) => item.testCaseStarted);
    }
    findAllTestCaseFinishedOrderBy(findOrderBy, order) {
        const withOrderBy = this.findAllTestCaseFinished().map((testCaseFinished) => ({
            testCaseFinished,
            orderBy: findOrderBy(this, testCaseFinished),
        }));
        const sorted = withOrderBy.sort((a, b) => {
            if (a.orderBy === undefined && b.orderBy === undefined)
                return 0;
            if (a.orderBy === undefined)
                return 1;
            if (b.orderBy === undefined)
                return -1;
            return order(a.orderBy, b.orderBy);
        });
        return sorted.map((item) => item.testCaseFinished);
    }
    findAllTestSteps() {
        return [...this.testStepById.values()];
    }
    findAllTestStepStarted() {
        return [...this.testStepStartedByTestCaseStartedId.values()];
    }
    findAllTestStepFinished() {
        return [...this.testStepFinishedByTestCaseStartedId.values()];
    }
    findAllTestRunHookStarted() {
        return [...this.testRunHookStartedById.values()];
    }
    findAllTestRunHookFinished() {
        return [...this.testRunHookFinishedByTestRunHookStartedId.values()];
    }
    findAllUndefinedParameterTypes() {
        return [...this.undefinedParameterTypes];
    }
    findAttachmentsBy(element) {
        if ('testStepId' in element) {
            return this.attachmentsByTestCaseStartedId
                .get(element.testCaseStartedId)
                .filter((attachment) => attachment.testStepId === element.testStepId);
        }
        else {
            return this.attachmentsByTestRunHookStartedId.get(element.testRunHookStartedId);
        }
    }
    findHookBy(item) {
        if ('testRunHookStartedId' in item) {
            const testRunHookStarted = this.findTestRunHookStartedBy(item);
            helpers_1.assert.ok(testRunHookStarted, 'Expected to find TestRunHookStarted from TestRunHookFinished');
            return this.findHookBy(testRunHookStarted);
        }
        if (!item.hookId) {
            return undefined;
        }
        return this.hookById.get(item.hookId);
    }
    findMeta() {
        return this.meta;
    }
    findMostSevereTestStepResultBy(element) {
        const testCaseStarted = 'testCaseStartedId' in element ? this.findTestCaseStartedBy(element) : element;
        return (0, lodash_sortby_1.default)(this.findTestStepFinishedAndTestStepBy(testCaseStarted).map(([testStepFinished]) => testStepFinished.testStepResult), [(testStepResult) => (0, helpers_1.statusOrdinal)(testStepResult.status)]).at(-1);
    }
    findLocationOf(pickle) {
        var _a;
        const lineage = this.findLineageBy(pickle);
        if (lineage === null || lineage === void 0 ? void 0 : lineage.example) {
            return lineage.example.location;
        }
        return (_a = lineage === null || lineage === void 0 ? void 0 : lineage.scenario) === null || _a === void 0 ? void 0 : _a.location;
    }
    findPickleBy(element) {
        const testCase = this.findTestCaseBy(element);
        helpers_1.assert.ok(testCase, 'Expected to find TestCase from TestCaseStarted');
        return this.pickleById.get(testCase.pickleId);
    }
    findPickleStepBy(testStep) {
        if (!testStep.pickleStepId) {
            return undefined;
        }
        return this.pickleStepById.get(testStep.pickleStepId);
    }
    findStepBy(pickleStep) {
        const [astNodeId] = pickleStep.astNodeIds;
        helpers_1.assert.ok(astNodeId, 'Expected PickleStep to have an astNodeId');
        return this.stepById.get(astNodeId);
    }
    findStepDefinitionsBy(testStep) {
        var _a;
        return ((_a = testStep.stepDefinitionIds) !== null && _a !== void 0 ? _a : []).map((id) => this.stepDefinitionById.get(id));
    }
    findSuggestionsBy(element) {
        if ('steps' in element) {
            return element.steps.flatMap((value) => this.findSuggestionsBy(value));
        }
        return this.suggestionsByPickleStepId.get(element.id);
    }
    findUnambiguousStepDefinitionBy(testStep) {
        var _a;
        if (((_a = testStep.stepDefinitionIds) === null || _a === void 0 ? void 0 : _a.length) === 1) {
            return this.stepDefinitionById.get(testStep.stepDefinitionIds[0]);
        }
        return undefined;
    }
    findTestCaseBy(element) {
        const testCaseStarted = 'testCaseStartedId' in element ? this.findTestCaseStartedBy(element) : element;
        helpers_1.assert.ok(testCaseStarted, 'Expected to find TestCaseStarted by TestStepStarted');
        return this.testCaseById.get(testCaseStarted.testCaseId);
    }
    findTestCaseDurationBy(element) {
        let testCaseStarted;
        let testCaseFinished;
        if ('testCaseStartedId' in element) {
            testCaseStarted = this.findTestCaseStartedBy(element);
            testCaseFinished = element;
        }
        else {
            testCaseStarted = element;
            testCaseFinished = this.findTestCaseFinishedBy(element);
        }
        if (!testCaseFinished) {
            return undefined;
        }
        return messages_1.TimeConversion.millisecondsToDuration(messages_1.TimeConversion.timestampToMillisecondsSinceEpoch(testCaseFinished.timestamp) -
            messages_1.TimeConversion.timestampToMillisecondsSinceEpoch(testCaseStarted.timestamp));
    }
    findTestCaseStartedBy(element) {
        return this.testCaseStartedById.get(element.testCaseStartedId);
    }
    findTestCaseFinishedBy(testCaseStarted) {
        return this.testCaseFinishedByTestCaseStartedId.get(testCaseStarted.id);
    }
    findTestRunHookStartedBy(testRunHookFinished) {
        return this.testRunHookStartedById.get(testRunHookFinished.testRunHookStartedId);
    }
    findTestRunHookFinishedBy(testRunHookStarted) {
        return this.testRunHookFinishedByTestRunHookStartedId.get(testRunHookStarted.id);
    }
    findTestRunDuration() {
        if (!this.testRunStarted || !this.testRunFinished) {
            return undefined;
        }
        return messages_1.TimeConversion.millisecondsToDuration(messages_1.TimeConversion.timestampToMillisecondsSinceEpoch(this.testRunFinished.timestamp) -
            messages_1.TimeConversion.timestampToMillisecondsSinceEpoch(this.testRunStarted.timestamp));
    }
    findTestRunFinished() {
        return this.testRunFinished;
    }
    findTestRunStarted() {
        return this.testRunStarted;
    }
    findTestStepBy(element) {
        return this.testStepById.get(element.testStepId);
    }
    findTestStepsStartedBy(element) {
        const testCaseStartedId = 'testCaseStartedId' in element ? element.testCaseStartedId : element.id;
        // multimaps `get` implements `getOrDefault([])` behaviour internally
        return [...this.testStepStartedByTestCaseStartedId.get(testCaseStartedId)];
    }
    findTestStepsFinishedBy(element) {
        const testCaseStarted = 'testCaseStartedId' in element ? this.findTestCaseStartedBy(element) : element;
        // multimaps `get` implements `getOrDefault([])` behaviour internally
        return [...this.testStepFinishedByTestCaseStartedId.get(testCaseStarted.id)];
    }
    findTestStepFinishedAndTestStepBy(testCaseStarted) {
        return this.testStepFinishedByTestCaseStartedId
            .get(testCaseStarted.id)
            .map((testStepFinished) => {
            const testStep = this.findTestStepBy(testStepFinished);
            helpers_1.assert.ok(testStep, 'Expected to find TestStep by TestStepFinished');
            return [testStepFinished, testStep];
        });
    }
    findLineageBy(element) {
        const pickle = 'astNodeIds' in element ? element : this.findPickleBy(element);
        const deepestAstNodeId = pickle.astNodeIds.at(-1);
        helpers_1.assert.ok(deepestAstNodeId, 'Expected Pickle to have at least one astNodeId');
        return this.lineageById.get(deepestAstNodeId);
    }
}
exports.default = Query;
//# sourceMappingURL=Query.js.map